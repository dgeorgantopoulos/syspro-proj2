Δημήτριος Γεωργαντόπουλος - sdi1900036
Προγραμματισμός Συστήματος - Εργασία 2η

ΟΔΗΓΙΕΣ ΕΚΤΕΛΕΣΗΣ:
Για τη δημιουργία του εκτελέσιμου αρχείου, απαιτείται η εντολή make all. Από εκεί και έκτοτε η εκτέλεση γίνεται επακριβώς όπως και στην εκφώνηση(το server ip δύναται να το βρεί κανείς μέσω της hostname -i). Το στοχευμένο directory, μαζί με τα αρχεία και όλα τα subdirectories του, δημιουργούνται μέσα στο φάκελο με τα αρχεία της εργασίας με τη μορφή path που έχει δοθεί στη γραμμή εντολών.

ΠΟΛΥ ΣΗΜΑΝΤΙΚΕΣ ΠΑΡΑΤΗΡΗΣΕΙΣ:
Στο όρισμα directory του client,πρέπει να τοποθετηθεί κανονικά ο χαρακτήρας "/" πριν το root directory(δηλαδή στη περίπτωση του server της σχολής πρέπει να γραφτεί ώς: 
/home/users/sdi1900036/testdir. Είναι επίσης σημαντικό να ΜΗΝ τοποθετηθεί / στο τέλος-τέλος.


Αρχείο server.c (σημαντικό κομμάτι για τη λειτουργία του server αλλά και του client έχει αξιοποιηθεί από τις διαφάνειες του μαθήματος της κυρίας Ρουσσοπούλου)

Όσον αφορά τον εξυπηρετητή, αρχικά μέσω atoi λαμβάνουμε τα απαραίτητα ορίσματα από τη γραμμή εντολής, τα οποία ονομάζονται ακριβώς όπως προτείνει η εκφώνηση (port,thread_pool_size,queue_size και block_size). Έχοντας πλέον αυτές τις πληροφορίες, μπορούμε να αρχικοποιήσουμε το thread pool(λειτουργία του θα αναλυθεί παρακάτω) και την ουρά εκτέλεσης queue(και αυτή να αναλυθεί λεπτομερώς στην εξήγηση του αρχείου work). Πρίν γίνει η οποιαδήποτε σύνδεση, δημιουργούνται όλα τα worker threads έτσι ώστε να είναι διαθέσιμα να εξυπηρετήσουν τους clients, με starting function την worker threads, και με όρισμα το αρχικοποιημένο μας queue για την επεξεργασία/χρήση του.

Τυπώνουμε τις παραμέτρους για την διευκόλυνση του χειριστή, και δηλώνουμε server,client τύπου sockaddr_in για την επικοινωνία μεταξύ του εξυπηρετητή και πελάτη. Κάνουμε το συνηθισμένο casting σε struct τύπου sockaddr, και δημιουργώ το αντίστοιχο socket sock, με AF_INET(αφού είναι internet domain) και SOCK_STREAM εφόσον έχουμε TCP,και πρωτόκολλο 0. Θέτω ως τύπο sin_family παλι το AF_INET(για ιντερνετικές διευθύνσεις v4). Ως s_addr θέτουμε INNADR_ANY(εφόσον θέλουμε να δεχόμαστε οποιαδήποτε σύνδεση μας έρχεται και όχι μια συγκεκριμένη),εφόσον πρώτα την έχουμε μετατρέψει στο σωστό byte order(δηλαδή το network), και ως port αυτό που έχουμε λάβει από την γραμμή εντολών. Με τη βοήθεια της setsockopt, κάνω configure το socket μου έτσι ώστε να μπορούν να ξαναχρησιμοποιούνται local addresses(αυτό είναι σημαντικό να γίνει εφόσον σε αντίθετη περίπτωση μπορεί να προκύψει το error code(bind:Adress already in use) σε περίπτωση που είχαν μείνει δεδομένα μέσα στο socket και η σύνδεση αυτή προηγουμένως έκλεισε. Αυτό γίνεται χρησιμοποιώντας το SO_REUSEADDR στο sock μέσω SOL_SOCKET(έτσι ώστε να "στοχοποιηθεί" το socket level). Κάνουμε bind έτσι ώστε η διεύθυνση του server να γίνει assign στο socket μας, και κάνω listen περιμένοντας για ενα connection στο socket μας. Μέσα σε αέναο loop while(1), κάθε σύνδεση η οποία μας έρχεται στο socket από τον client την αποδεχόμαστε με την accept. Ύστερα, δηλώνουμε το pthread_t com_t το οποίο θα λειτουργήσει ως communication thread για κάθε νεα σύνδεση που δέχεται ο server μας. Δεσμεύουμε δυναμικά τον απαραίτητο χώρο, και αναθέτουμε στα "μελη" του struct το queue μας και το filedescriptor από το socket του client(η αναλυτικότερη εξήγηση του struct γίνεται στο τμήμα του αρχείου functions.h). Μέσω της pthread_create δημιουργούμε το αντίστοιχο thread, το οποίο κατά τη δημιουργία του ξεκινά η συνάρτηση serve_client για την εξυπηρέτηση του αιτήματος του πελάτη,με argument τη μεταβλητή ονόματι args τύπου thread_args(εξηγείται παρακάτω. Συνοπτικά, περιέχει την ουρά αρχείων και filedescriptor socket για την ευκολότερη πρόσβασή του από το communication thread).

Αρχείο functions.c/.h
Το struct thread_args αξιοποιείται ως απλή δομή αποθήκευσης έτσ ώστε να έχει εύκολη πρόσβαση το communication thread στο queue διεργασιών-αρχείων, εξού και αποτελείται απο τα: WorkQUeue *Queue, και ενα filedescriptor fd, όπου αναλογεί στο socket που αποδέχεται αιτήσεις ο server μας από τον client.

	recurse (βασισμένο στη λογική του topic 3 - σελ 46 της κυρίας Ρουσσοπούλου)

Η συνάρτηση recurse, αφορά την αναδρομική περιήγηση στα αρχεία ενος δοθέντος path, η οποία θα πρέπει προφανώς να ανιχνεύει και τα αρχεία σε τυχόν subdirectories. Αρχικά, κρατάμε char cur μήκος 4095(το έχουμε τέτοιο μέγεθος εφόσον σε αυτό θα γίνονται concat τα υπάρχοντα paths), και το γεμίζουμε με μηδενικά. Ύστερα, με τη βοήθεια της βιβλιοθήκης dirent, δηλώνουμε το struct dirent **fil, το οποίο θα αξιοποιείται για την πρόσβαση των αρχείων/subdir τα οποία ψάχνουμε στο path in που μας έχει δοθεί ως όρισμα. Η scandir, επιστρέφει τον αριθμό των entries που βρίσκονται στο path που δίνεται ως πρώτο όρισμα. Η scandir αξιοποιήθηκε αντί της readdir, εφόσον η πρώτη μπορεί να λάβει το όρισμα alphasort, το οποίο γυρνάει τα επιθυμητά αποτελέσματα με αλφαβητική σειρά(δηλαδή έτσι όπως εμφανίζονται τα αρχεία ενος directory στο unix, ενώ αντιθέτως η readdir τα επιστρέφει με εντελώς τυχαία σειρά). Άρα, μέσω if ελέγχουμε αν το path είχε μέσα κάποιο αριθμό αρχείων, και σε περίπτωση που ναι, αξιοποιούμε while loop για κάθε ένα απτα entries στο path μας, αγνοώντας τα "." και ".." εφόσον εκπροσωπούν τα current και previous directory αντιστοίχως. Αρχικά, κάνουμε strcpy το αρχικό path που μας έχει δοθεί στο cur(έτσι "γράφουμε πάνω" και εξαφανίζουμε τα κατάλοοιπα απόο προηγούμενες επαναλήψεις/entries. Κάνω concatenate το "/", και το fil[count]->name, το οποίο αποτελεί απλώς το όνομα του αρχείου/directory μας. Καλούμε τη συνάρτηση stat στο αρχείο που εξετάζουμε τώρα, και αποθηκεύουμε το αποτέλεσμα στο struct stat s. Η συγκεκριμένη συνάρτηση ελέγχει τις πληροφορίες του συγκεκριμένου αρχείου, το οποίο είναι αναγκαίο εφόσον θέλουμε να γνωρίζουμε πόττε είμαστε αντιμέτωποι με directory, έτσι ώστε να κληθεί αναδρομικά η συνάρτηση και να τυπωθούν και αυτού τα περιεχόμενα. Άρα, βλέπουμε με ενα απλό bitwise and με την IFMT, αν στο s, έχει γίνει set το bit που υποδηλώνει οτι το συγκεκριμένο αρχείο είναι directory,τότε και καλούμε αναδρομικά τη συνάρτηση.  Σε περίπτωση που ισχύει, η συνάρτηση καλεί τον εαυτό της έτσι ώστε να ελέγξει το directory. Σε περίπτωση όμως, που έχουμε αρχείο, τότε δημιουργούμε νεα μεταβλητή τύπου work ώστε να μεταφέρουμε σε αυτή το όνομα του αρχείου, και το filedescriptor που αναλογεί στο socket του server.
Για να κάνουμε thread_safe την εκτύπωση στο stdout, την κάνουμε lock για το stdio. Πλέον, τυπώνουμε αυτό που επιθυμούμε(την προσθήκη του αρχείου από το αντίστοιχο thread),  και κάνουμε unlock το stdout. Εν τέλει, καλούμε τη συνάρτηση για την προσθήκη του αρχείου στην ουρά εκτέλεσης(γίνεται εκεί ο έλεγχος για αν αυτή είναι γεμάτη κλπ),ενώ αυξάνεται το counter για τον συνολικό αριθμό αρχείων. Εν τέλει, αποδεσμεύουμε τη μνήμη που αξιοποίησε το dirent **fil (εφόσον η scandir δεσμεύει αυτομάτως χώρο).

	int_to_string
Συνάρτηση που θα αξιοποείται για την σηματοδότηση πως το διάβασμα από ενα συγκεκριμένο directory έχει τελειώσει(αυτό θα γίνεται μέσω δημιουργίας αντίστοιχου τέτοιου αρχείου με ανάλογο όνομα στην ουρά-η διαδικασία εξηγείται στην παρακάτω συνάρτηση).Δοθέντος ενός αριθμού(ο οποίος θα είναι ο αριθμός των αρχείων τα οποία βρίσκονται σε ένα directory), η συνάρτη θα παράγει το string "^num_of_files".

	serve_client
Συνάρτηση που αναλαμβάνει το communication thread. Λαμβάνει ως όρισμα τα thread_args που του περνάμε στον server, γι'αυτό και κάνουμε cast το void *arg σε μεταβλητή τύπου thread_args, ενώ αναθέτουμε σε μεταβλητή την ουρά εκτέλεσης και το filedescriptor του server. Κρατάμε πίνακα buf τον οποίον αρχικοποιούμε γεμίζοντας με μηδενικά. Διαβάζουμε από το fd του server (δηλαδή διαβάζουμε το αίτημα του client, η πιο συγκεκριμένα, το path του directory που έχει δοθεί ως όρισμα στη γραμμή εντολών, και το τοποθετούμε στο buf). Kάνοντας πάλι flock τυπώνουμε ποιο directory επρόκειτο να scanάρουμε, και καλούμε την recurse, με όρισματα το buf, το fd το WorkQueue q και τη μεταβλητή count. Εν τέλει, καλούμε την int_to_string με όρισμα τον συνολικό αιρθμό αρχείων του δοθέντος path, και την αποθηκεύουμε στη μεταβλητή char* end_msg. Αυτό το μήνυμα, το περνάω ως όνομα αρχείου σε μεταβλητή τύπου work, λετσι ώστε να τη τοποθετήσω στην ουρά εκτέλεσης για να το γνωρίζει το parse_file.


Αρχείο work.c/.h
	Όσον αφορά την υλοποίηση της ουράς εκτέλεσης, ρχικά δημιουργούμε struct Work, το οποίο θα εμπεριέχει char *filename για το όνομα ενός αρχείου, int fd για το filedescriptor του socket στο οποίο θα στέλνει, και workerFunction fun η οποία θα θα τεθεί ως η συνάρτηση parse_file (εξού και λαμβάνει ορίσματα τύπου WorkQueue*,char* και int) που θα εκτελεί κάθε φορά που αναλαμβάνει μια δουλειά-αρχικά λαμβάνοντας δηλαδή ενα path ένα worker thread. To WorkQueue, το οποίο προφανώς αντιπροσωπεύει την ουρά εκτέλεσης, θα αποτελείται από πολλά struct work(εφόσον στην ουρά θα μπαίνουν πολλα αρχεία). Ταυτόχρονα θα διατηρείται το blocksize του μπλοκ των αρχείων που θα στέλνουν τα worker threads μέσω της sockWrite. Πέραν των αρχείων, στο WorkQueue τοποθετούμε και όλα τα επιθυμητά μας mutex και condition variables(ευκολότερη πρόοσβαση σε αυτά αλλά και καλύτερη οργάνωση από απλή global αξιοποίησή τους.Η χρήση τους θα αναλυθεί περισσότερο στις αντίστοιχες συναρτήσεις χρήσης τους).

	pack_file_message
Δοθέντος του ορίσματος path, το οποίο αποστέλεται από το αντίστοιχο path που έχει λάβει η parse_file, αρχικά αυτό σώζεται στη μεταβλητή msg. Με τη βοήθεια της συνάρτησης stat, ανιχνεύουμε το μέγεθος του αρχείου που αναπαριστά το path(εφόσον αυτό αποτελεί σημαντικό metadata ενος αρχείου). Σε πίνακα fsize(με δώδεκα θέσεις για ασφάλεια σε περίπτωση ιδιαίτερα μεγάλου αρχείου), τοποθετούμε το αντίστοιχο μέγεθος st_size (μέλος του struct stat s). Παράλληλα, κάνουμε reallocate τη μνήμη που έχει δεσμευθεί για το msg, καθώς σε αυτό πλέον θα θέλουμε να αποθηκεύσουμε το ήδη υπάρχον path, το μήκος του μεγέθους του (+5 εφόσον κάνουμε strcat δυο φορές το @@, και ένα για το /0), αλλά και τα ίδια τα περιεχόμενα του αρχείου. Άρα, το message που έχει στην αρχή το path, με strcat του "κολλάμε" @@(έτσι ώστε μόλις το λάβει ο client να είναι εύκολος ο διαχωρισμός και αναγνώριση του μηνύματος) και το fsize και πάλι ενα @@. Όσον αφορά για τα περιεχόμενα του αρχείου, αυτά αρχικά θα αποθηκευθούν προσωρινά στον πίνακα buf(θέσεων όσο το μέγεθος του αρχείου μας, +1 για /0). "Ανοίγουμε" το αρχείο, και μέσω read γράφουμε όλα του τα δεδομένα στο πίνακα, τον οποίον και ύστερα κάνουμε concatenate στο msg. Πλέον, το msg θα έχει τη μορφή: "όνομα_αρχείου@@μέγεθος_αρχείου@@περιεχόμενα".

	parse_file
Σε περίπτωση που το path όπου έχει σταλθεί στη συνάρτηση είναι της μορφής "^num", αυτό αποτελεί το σήμα κατατεθέν που δηλώνει τη λήξη διαβάσματος-προσθήκης αρχείων στην ουρά δοθέντος ενος path(συνάρτηση int_to_string). Αν έχουμε λάβει τέτοιο μήνυμα, κλειδώνουμε το write_mutex, έτσι ώστε να γράψοουμε στο socket το αντίστοιχο "μήνυμα τέλους". Μόλις γίνει αυτό, κάνουμε unlock το mutex και λήγουμε την εκτέλεση.
Σε αντίθετη περίπτωση κάνοντας thread-safe το stdout μέσω της flockfile, τυπώνουμε το id tου thread αλλά και ποιο αρχείο επρόκειτο να διαβάσει, κάνοντας ύστερα funlock το stdout. Στη μεταβλητή msg καλούμε την συνάρτηση pack_file_message, έτσι ώστε πλέον σε αυτή να βρίσκεται το μήνυμα της μορφής "filename@@size@@contents". Για ενα επιβεβαιώσουμε πως δεν προκύπτει κανένα race condition όσο γράφουμε στο socket, κλειδώνουμε το write_mutex, και γράφουμε το αντίστοιχο μήνυμα μέσω SocketWrite στο filedescriptor fd δηλαδή στον client, με μέγεθος block size για το οποίο έχουμε πρόσβαση μέσω του struct WorkQueue.

	init_worker
Απλή συνάρτηση αρχικοποίησης του struct Work, δεσμεύοντας την απαραίτητη μνήμη δυναμικά που απαιτεί το struct, και αναθέτει στο filename και fd τις αντίστοιχες τιμές που έχει λάβει ως ορίσματα. Ταυτόχρονα, ορίζει ως την συνάρτηση fun την parse_file που θα εκτελείται από κάθε worker thread.

	initWorkerQueue
Συνάρτηση αρχικοποίησης του struct WorkQueue, δεσμεύοντας δυναμικά την μνήμη που απαιτεί το struct, ανατέθουμε στο block_size και size από τα ορίσματα της συνάρτησης, και κάνουμε initialise μέσω mutex_init και cond_init τα αντίστοιχα condition variables και mutexes. Τέλος, κάνουμε κάθε θέση του queue να δείχνει σε NULL.

	fullWorkQueue/emptyWorkQueue
Απλές συναρτήσεις όπου δοθέντος ενός WorkQueue, ελέγχουν αν αυτό είναι γεμάτο ή άδειο από αρχεία αντιστοίχως.(Η fullWorkQueue προφανώς αξιοποιείται για το σταμάτημα επιπλέον προσθήκης αρχείων στην ουρά αν αυτή είναι γεμάτη, και η emptyWorkQueue για το σταμάτημα των workerThreads σε περίπτωση που η  ουρά είναι άδεια)

	addWorkQueue(η φιλοσοφία λειτουργίας ακολουθεί αυτή των διαφανειών της κυρίας ρουσσοπούλου για τα condition variables)
Δοθέντος ενός WorkQueue και μιας δουλειάς/αρχείου work, lockάρουμε αρχικά το work_mutex, το οποίο θα αξιοποιείται για να επιβεβαιωθούμε οτι κάθε φορά που προσθέτουμε αρχεία σε ενα queue, να μην προσπαθήσει κάποιο αλλο thread να προσθέσει και αυτό, αλλά να περιμένει(έτσι ώστε να μην υπάρηξει conflict την διαμοιραζόμενη μνήμη). Ύστερα, ελέγχοντας πάντοτε οτι το queue δεν είναι γεμάτο, κάνουμε με τον συνήθη τρόπο wait στο condition variable work_cond που είναι "συνδεδεμένο" με το cond_mutex. Πλέον, στο "πίσω μέρος" του queque,στη πρώτη μη NULL θέση(δηλαδή στο queue->rear), αναθέτουμε την "δουλειά"-αρχείο που θέλουμε να προσθέσουμε, και αυξάνουμε το rear κατά 1(για να σηματοδοτήσουμε την νεα "τελευταία" θέση). Μέσω broadcast πλέον ξυπνάω κάθε thread που περιμένει στο work_cond condition variable για να συνεχίσουν, και ύστερα κάνουμε unlock το mutex.

	popWorkQueue
Σε περίπτωση που το queue είναι άδειο, τότε προφανώς δεν μπορούμε να κάνουμε pop οτιδήποτε, άρα και γυρνάμε αυτομάτως. Σε περίπτωση που όντως βρίσκονται αρχεία μέσα στην ουρά, αναθέτουμε σε μεταβλητή top τύπου work* το πρώτο work που βρίσκεται στο queue. Αυξάνουμε το front κατά 1 έτσι ώστε να γίνει dequeue η δουλειά. Σε περίπτωση που το front έχει φτάσει στο rear, κάνουμε reset και τα δύο ώστε να ξαναρχίσει το μέτρημα.

	workerThread
Η προκειμένη συνάρτηση αποτελεί το start routine που καλείται κατα τη διάρκεια δημιουργίας κάθε ενός από τα worker threads. Ως όρισμα δηλώνουμε οτι λαμβάνει το void* arg(τυπικό για τα τhreads), το οποίο εν τέλει κάνουμε cast σε μεταβλητή workQueue q(το ίδιο το queue μας όντως περνιέται ως argument στο server.c, λειτουργία για δήλωση ορίσματος). Μέσα σε αέναο loop, αρχικά μέσω του mutex lock κλειδώνεται το mutex: work_mutex έτσι ώστε να μην υπάρξει ταυτόχρονη πρόσβαση σε shared memory και δημιουργηθούν προβλήματα. Με τον συνήθη τρόπο βάσει των διαφανειών,όσο η ουρά εκτέλεσης είναι άδεια(άρα και δεν υπάρχουν διαθέσιμα αρχεία) κάνουμε wait στο condition variable το οποίο είναι "δεμένο" με το work_mutex. Μόλις συνεχίσουμε(άρα δεν είναι πλέον άδειο το queue) κάνουμε pop ένα αρχείο από μέσα του. Όσο το όνομα του αρχείου είναι διαφορετικού του "END", τυπώνουμε το ίδιο το όνομα του αρχείου το οποίο θα επεξεργαστούμε, αλλά και το fd socket του client στον οποίον θα γράψουμε, στη μορφή <filename,fd>. Καλούμε την cond_signal έτσι ώστε να "ξυπνήσουν" τυχόν threads που είνα κολλημένα σε τέτοιο condition variable, ενώ κάνουμε unlock το συγκεκριμένο mutex(work mutex) εφόσον πλέον έχουμε σταματήσει την επεξεργασία της διαμοιραζόμενης μνήμης. Σε περίπτωση ποου αυτό που έχουμε βγάλει όντως κάτι απτην ουρά εκτέλεσης, εκτελούμε την συνάρτηση fun (parse file δηλαδή) με ορίσματα το WorkQueue q, το όνομα του αρχείου που έχει προκύψει, και το fd του client ώστε να διαβάσει τα δεδομένα που θα του στείλουμε(όνομα αρχείου, μεγεθος,περιεχόμενα).

Αρχείο client.c 
Αρχικά κρατάμε πίνακα ip 20 θέσεων, ο οποίος θα αξιοποιείται για την αποθήκευση της IP διεύθυνσης την οποία θα χρησιμοποιεί ο server μας. Αυτή λαμβάνεται ως argument,  γιαυτό και το "γράφουμε" στον πίνακα μέσω στης strcopy. Ταυτόχρονα, μέσω της socket δημιουργούμε το αντίστοιχο endpoint για επικοινωνία μεταξύ server-client, με ορίσματα SOCK_STREAM(εφόσον είναι της μορφής TCP και όχι UDP),και πρωτόκολλο 0, κάνοντας και το αντίστοιχο error checking. Ακόμα, μέσω του server (το sockaddr_in τύπου struct), θα έχουμε την ικανότητα να συνδεθούμε στον αντίστοιχο server μας. Έχοντας κάνει πρώτα το συνηθισμένο casting στην μεταβλητή serverptr, τύπου sockaddr, θέτουμε ως τύπο sin_family το AF_INET(αφού είναι internet domain), ενώ ως address θέλουμε να περάσουμε την συγκεκριμένη ip του server η οποία μας έχει δοθεί ως command line argument, έχοντας τη πρώτα μετατρέψει στην αρμόζουσα μορφή της με την inet_addr(η οποία μετατρέπει το τυπικό IP σε integer κατάλληλο για χρήση), ενώ ως port πάλι το όρισμα το οποίο μας έχει δοθεί από την γραμμή εντολών(έχοντας το πρώτα "μετατρέψει" να έχει network byte order). Κάνουμε την αντίστοιχη σύνδεση στον server μέσω της connect, και με την βοήθεια της write στέλνουμε στο socket το αίτημά μας, δηλαδή το όνομα του directory που έχει δοθεί πάλι ως όρισμα στη γραμμή εντολών.
Μέσα σε αέναο loop, διαβάζουμε από το socket έτσι ώστε να λάμβουμε το μήνυμα μας(δηλ. στις περισσότερες περιπτώσεις filename@@size@@content. Στη περίπτωση που ο πρώτος χαρακτήρας είναι το "^" σημαίνει πως έχει φτάσει το μήνυμα τέλους, άρα μπρούμε να ξέρουμε και τον αριθμό αρχείων, κάνοντας ενα atoi. Σε περίπτωση που το μήνυμά μας είναι κανονικό, καλούμε την cre για την δημιουργίαα των ανάλογων directories/δημιουργία αρχείου κλπ..


ΣΥΝΕΧΕΙΑ ΑΡΧΕΙΟΥ functions.c

	socketWrite
Η συνάρτηση θα αξιοποείται για το γράψιμο στο socket από την parsefile. Ως ορίσματα λαμβάνει το filedescriptor του client, bufferSize, το οποίο αποτελεί ουσιαστικά το block size το οποίο έχει ληφθεί από την από την γραμμή εντολών, αλλά και το μήνυμα που έχει μετατραπεί στη κατάλληλη μορφή με τη βοήθεια της pack_file_message. Σώζουμε το μέγεθος του μηνύματος msg σε πίνακα msg_value, σε μορφή "^num^" ώστε να είναι εύκολα αναγνωρίσιμο από την read. Σε περίπτωση που το μήνυμα που θέλουμε να στείλουμε στο pipe είναι μεγαλύτερο από το μέγεθος του μπλοκ των αρχείων, τότε το τεμαχίζουμε, γνωρίζοντας οτι ο αριθμός των "τεμαχίων" msg_num, είναι το αρχικό μήκος του μηνύματός μας, διαιρούμενο με το blocksize, από το οποίο έχει αφαιρεθεί ο αιρθμός 14(12 για integer, 2 για τα δυο σύμβολα ^).Αν αυτό αφήνει υπόλοιπο διαφορετικό του μηδενός(έχουν ξεμείνει κάποια byte, απλώς λέμε πως θα στείλουμε άλλο ενα τεμάχιο). Το μήκος του κάθε μηνύματος θα είναι απλώς το μέγεθος ολόκληρου του μηνύματος, διαιρεμένο με τον αριθμό των τεμαχίων. Για κάθε ένα από αυτά τα τεμάχια,
δημιουργώ πίνακα divvided_msg[msg_len+1](για το /0) όπου θα σώζεται το διαχωρισμένο μήνυμα. Ταυτόχρονα, γεμίζω με μηδενικά του msg_value(εφόσον τώρα τσεκάρουμε το μήνυμα του "κομμένου"),divided_msg και total_output. Σε περίπτωση που βρίσκομαστε στο τελευταίο κομμάτι, και το μέγεθος του, είναι μικρότερο αυτό του τυπικού κομματιού, τότε στην divided_msg, μπαίνει το μέγεθος του υπολοιπόμενου κομματιού, και όχι ολόκληρο το τυπικό μέγεθος. Σε αντίθετη περίπτωση, στο divided_msg απλώς βάζουμε το i-οστό τμήμα του αρχικού μηνύματος με το τυπικό μέγεθος που ΄χει υπολογιστεί παραπάνω. Πέρνουμε πλέον το συνολικό μέγεθος του νέου "σπασμένου" μηνύματος,και το σώζουμε πάλι στη μορφή "^num^" στο char msg_value. Κάνουμε copy στο total_outpout το μέγεθος αυτό και ύστερα το μήνυμα(το κομμάτι που του αναλογεί εφόσον έχει σπαστεί το συνολικό). Σε περίπτωση που βρισκόμαστε στο τελευταίο "κομμάτι", κάνουμε strcat ενα χαρακτήρα # στο τέλος για να γνωρίζουμε πότε έχει έρθει η λήξη του μηνύματος στο socketRead. Εν τέλει, γράφουμε στο socket του client μέσω write το μήνυμα μας.
Σε αντίθετη περίπτωση, δηλαδή όταν το τελικό μήνυμα είναι μικρότερο από το buffersize, τότε δεν διατρέχουμε κανένα κίνδυνο, και γράφουμε στο πίνακα total_outpout αρχικά το μήκος του μεγέθος(ανάμεσα σε δυο ^) αλλά και το ίδιο το μήνυμα, όπου στο τέλος θα έχει ένα χαρακτήρα # έτσι ώστε η socketRead να αναγνωρίζει ότι το γράψιμο στο socket έχει λήξει. Μέσω της write το γράφω στο socket (+1 χαρακτήρα, ο οποίος δύναται να το #),και λήγει η εκτέλεση.

	SocketRead
Η συνάρτηση λαμβάνει μόνο ένα όρισμα, το οποίο είναι το filedescriptor το οποίο θα αξιοποιούμε ώστε να διαβάζει το client από το socket. Μέσα σε αέναο loop, διαβάζουμε τον πρώτο χαρακτήρα. σε  περίπτωση που δεν είναι ο αναμενόμενος(^), εφόσον έχουμε κάνει το +1 από πάνω, μέσω while διαβάζουμε εναν-εναν χαρακτήρες μέχρι να προκύψει ο επιθυμητός. Μετά τον χαρακτήρα αυτόν ακολουθεί το μέγεθος του μηνύματος. Για να διαβάσουμε ολόκληρο το μέγεθος, διαβάζουμε εναν-εναν τους αριθμούς, και το τοποθετούμε σε ανάλογο buffer. Μόλις βρεθεί το δεύτερο ^, αυτό σηματοδοτεί πως το αναγγελία του μεγέθους του σπασμένου μηνύματος έχει τελειώσει. Εφόσον είναι αποθηκευμένο σε char πίνακα, το μετατρέπω μέσω atoi σε integer(msg_size). Διαβάζω μέσω read το ανάλογο κομμάτι μεγέθους msg_size και τον σώζω στην total_imput. Ακόμα, διαβάζω ένα επιπλέον byte, έτσι ώστε να ελέγξω αν αυτό εμπεριέχει το #(η λήξη του μηνύματος στο τελευταίο κομμάτι). Πλέον, κάνω reallocate τη μνήμη που έχει δεσμευθεί για το msg, έτσι ώστε πλέον να καταλαμβάνει όσο η προηγούμενη msg(1), μαζί με το νέο μήνυμα +2(+1 για το τελευταίο χαρακτήρα και +1 για /0). Κολλάμε στο msg, το σπασμένο κομμάτι του μηνύματος(που βρίσκεται στην total_input), και αποδεσμεύουμε τη μνήμη που είχε καταλάβει η total_input. Σε περίπτωση που το msg_end, δηλαδή ο τελευταίος χαρακτήρας είναι #,  τότε φτάσαμε στη λήξη του μηνύματος, άρα και σταματάμε. Σε αντίθετη περίπτωση, κολλάμε αυτό(που αποτελεί το τελευταίο γράμμα) στο msg. Εν τέλει, διαβάζουμε ενα τελευταίο για να καθαριστεί το buffer.

	cre
Έχοντας ως όρισμα ενα μήνυμα της μορφής path@@size@@contents, σκοπευούμε να το κατατμήσουμε, έτσι ώστε να γράψουμε στο αντίστοιχο αρχείο. Το μήνυμα βρίσκεται στη μεταβλητή msg, όπου με τη βοήθεια της strtok, λαμβάνουμε το πρώτο κομμάτι αριστερά του πρώτου @@, το οποίο είναι το μονοπάτι του αρχείου. Με την κλήση της strtok με όρισμα NULL πλέον, λαμβάνουμε το "μεσαίο" κομμάτι (το μέγεθος) και το δεξί (τα περιεχόμενα). Πλέον, στόχος μας είναι η επεξεργασία του absolute path. Απαραίτητη είναι η απομόνωση του κάθε ενος "κομματιού" των directories. Συγκεκριμένα σώζουμε ολόκληρο το path στον πίνακα whole με τη βοήθεια της strcpy, και με την strrchr ανιχνεύω την τελευταία εμφάνιση του χαρακτήρα "/", έχοντας pointer τύπου char με όνομα sta, να δείχνει σε ακριβώς αυτό το σημείο. Εφόσον αυτή είναι η τελευταία εμφάνισή του /, στα δεξιά του θα βρίσκεται σκέτο το όνομα του αρχείου, ενώ στα αρίστερα ολόκληρο το path από subdirectories στα οποία τυχόν εμπεριέχεται. Για να κρατήσω αποκλειστικά αυτό το μονοπάτι από directories, απλώς σηματοδοτώ ο pointer sta, να δείχνει πλέον στο \0 για να σηματοδοτήσωτη λήξη του string, και το οποίο path το αποθηκεύω στον πίνακα odir. Αντιγράφω τον πίνακα odir στον nam(εφόσον θα εφαρμόσω την strtok, και θα τον κατατμήσει, και ενδεχομένως να τον χρειαστούμε για χρήση στο μέλλον). Τo char usefmk θα αξιοποείται για την αποθήκευση του κάθε subdirectory το οποίο θα δημιουργείται. Συγκεκριμένα, διαχωρίζοντας το με βάση το "/", αρχικά παίρνουμε το root directory(αν όλα είναι σωστά). Εφόσον αυτό δεν είναι NULL, το κάνω concatenate μαζί με ενα /(εφόσον έχει χαθεί λόγω strtok) στο usfmk,και καλώντας την συνάρτηση makedir δημιουργώ το αντίστοιχο directory(δεν υπάρχει πρόβλημα αν αυτό υπάρχει ήδη, εφόσον αν κάτι τέτοιο ισχύει, απλώς η συνάρτηση αποτυγχάνει).Ταυτόχρονα, κάνω strtok με πλέον όρισμα NULL, έτσι ώστε να πάρω το ακριβώς επόμενο κομμάτι, το οποίο πάλι "κολλάω" στο τέλος της usefmk, και κάλω την mkdir κλπ... Πλέον, έχουν δημιουργηθεί όλα τα απαραίτητα (sub)directories. Τώρα θα ασχοληθούμε με το συγκεκριμένο αρχείο. Μέσω της συνάρτησης stat, ελέγχουμε αν το αρχείο(του οποίου το path είναι σωσμένο στο whole), υπάρχει στο σύστημά μας. Αν αυτό ισχύει, τότε όπως απαιτεί η εκφώνηση, αυτό αφαιρείται μέσω της unlink. Παράλληλα, μέσω της open "ανοίγουμε" το αρχείο που βρίσκεται στο whole(ταυτοχρόνως δημιουργώντας το μέσω του flag O_CREAT, και θέλουμε να έχοουμε δικαιώματα και ανάγνωσης αλλά κα γραψίματος, οπότε με O_RDWR. Γράφουμε στον fildescriptor που εκροσωπεί το αρχείο το buffer cont που εμπεριέχει όλα τα απαραίτητα περιεχόμενα, και ύστερα το κλείνουμε.